"use strict";
var _extensions, _engines, _cachePaths;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformViews = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = require("path");
const PlatformViewsSettings_1 = require("../../config/interfaces/PlatformViewsSettings");
function patchEJS(ejs) {
    return {
        compile(str, { client, ...options }) {
            return (ejs || require("ejs")).compile(str, options);
        }
    };
}
async function tryImport(name) {
    try {
        return await Promise.resolve().then(() => tslib_1.__importStar(require(name)));
    }
    catch (er) {
        // istanbul ignore next
    }
}
/**
 * @platform
 */
let PlatformViews = class PlatformViews {
    constructor() {
        _extensions.set(this, void 0);
        _engines.set(this, new Map());
        _cachePaths.set(this, new Map());
    }
    async $onInit() {
        tslib_1.__classPrivateFieldSet(this, _extensions, new Map(Object.entries({
            ...PlatformViewsSettings_1.PLATFORM_VIEWS_EXTENSIONS,
            ...this.extensionsOptions
        })));
        await this.loadFromConsolidate();
        await this.loadFromTsedEngines();
    }
    /**
     * @deprecated
     */
    async loadFromConsolidate() {
        const cons = await tryImport("consolidate");
        if (cons) {
            cons.requires.ejs = patchEJS(cons.requires.ejs);
            tslib_1.__classPrivateFieldGet(this, _extensions).forEach((engineType) => {
                if (cons[engineType]) {
                    const options = this.getEngineOptions(engineType);
                    if (options.requires) {
                        cons.requires[engineType] = options.requires;
                    }
                    this.registerEngine(engineType, {
                        options,
                        render: cons[engineType]
                    });
                }
            });
        }
    }
    async loadFromTsedEngines() {
        const tsed = await tryImport("@tsed/engines");
        if (tsed) {
            tsed.requires.set("ejs", patchEJS(tsed.requires.get("ejs")));
            tslib_1.__classPrivateFieldGet(this, _extensions).forEach((engineType) => {
                if (tsed.engines.has(engineType)) {
                    const options = this.getEngineOptions(engineType);
                    if (options.requires) {
                        tsed.requires.set(engineType, options.requires);
                    }
                    this.registerEngine(engineType, {
                        options,
                        render: tsed.getEngine(engineType)
                    });
                }
            });
        }
    }
    getEngines() {
        return [...tslib_1.__classPrivateFieldGet(this, _extensions).entries()].map(([extension, engineType]) => {
            const engine = this.getEngine(this.getExtension(engineType));
            return {
                extension,
                engine
            };
        });
    }
    registerEngine(engineType, engine) {
        tslib_1.__classPrivateFieldGet(this, _engines).set(engineType, engine);
        return this;
    }
    getEngine(type) {
        return tslib_1.__classPrivateFieldGet(this, _engines).get(tslib_1.__classPrivateFieldGet(this, _extensions).get(type) || type);
    }
    getEngineOptions(engineType) {
        return core_1.getValue(this.engineOptions, engineType, {});
    }
    async render(viewPath, options = {}) {
        const { path, extension } = tslib_1.__classPrivateFieldGet(this, _cachePaths).get(viewPath) || tslib_1.__classPrivateFieldGet(this, _cachePaths).set(viewPath, this.resolve(viewPath)).get(viewPath);
        const engine = this.getEngine(extension);
        if (!engine) {
            throw new Error(`Engine not found to render the following "${viewPath}"`);
        }
        return engine.render(path, Object.assign({ cache: this.cache || this.env === core_1.Env.PROD }, engine.options, options));
    }
    getExtension(viewPath) {
        return (path_1.extname(viewPath) || this.viewEngine).replace(/\./, "");
    }
    resolve(viewPath) {
        const extension = this.getExtension(viewPath);
        viewPath = viewPath.replace(path_1.extname(viewPath), "") + "." + extension;
        const path = [
            viewPath,
            path_1.resolve(path_1.join(this.root, viewPath)),
            path_1.resolve(path_1.join(process.cwd(), "views", viewPath)),
            path_1.resolve(path_1.join(process.cwd(), "public", viewPath))
        ].find((file) => fs_1.default.existsSync(file)) || viewPath;
        return {
            path,
            extension
        };
    }
};
_extensions = new WeakMap(), _engines = new WeakMap(), _cachePaths = new WeakMap();
tslib_1.__decorate([
    di_1.Constant("env"),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "env", void 0);
tslib_1.__decorate([
    di_1.Constant("views.root", `${process.cwd()}/views`),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "root", void 0);
tslib_1.__decorate([
    di_1.Constant("views.cache"),
    tslib_1.__metadata("design:type", Boolean)
], PlatformViews.prototype, "cache", void 0);
tslib_1.__decorate([
    di_1.Constant("views.viewEngine", "ejs"),
    tslib_1.__metadata("design:type", String)
], PlatformViews.prototype, "viewEngine", void 0);
tslib_1.__decorate([
    di_1.Constant("views.extensions", {}),
    tslib_1.__metadata("design:type", Object)
], PlatformViews.prototype, "extensionsOptions", void 0);
tslib_1.__decorate([
    di_1.Constant("views.options", {}),
    tslib_1.__metadata("design:type", Object)
], PlatformViews.prototype, "engineOptions", void 0);
PlatformViews = tslib_1.__decorate([
    di_1.Injectable()
], PlatformViews);
exports.PlatformViews = PlatformViews;
//# sourceMappingURL=PlatformViews.js.map