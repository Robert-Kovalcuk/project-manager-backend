"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformHandler = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const logger_1 = require("@tsed/logger");
const mvc_1 = require("../../mvc");
const PlatformResponseFilter_1 = require("../../platform-response-filter/services/PlatformResponseFilter");
const HandlerContext_1 = require("../domain/HandlerContext");
const ParamValidationError_1 = require("../errors/ParamValidationError");
const createHandlerMetadata_1 = require("../utils/createHandlerMetadata");
const renderView_1 = require("../utils/renderView");
const setResponseHeaders_1 = require("../utils/setResponseHeaders");
function shouldBeSent(data) {
    return Buffer.isBuffer(data) || core_1.isBoolean(data) || core_1.isNumber(data) || core_1.isString(data) || data === null;
}
function shouldBeSerialized(data) {
    return !(core_1.isStream(data) || shouldBeSent(data) || data === undefined);
}
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */
let PlatformHandler = class PlatformHandler {
    constructor(injector) {
        this.injector = injector;
    }
    /**
     * Create a native middleware based on the given metadata and return an instance of HandlerContext
     * @param input
     * @param options
     */
    createHandler(input, options = {}) {
        const metadata = this.createHandlerMetadata(input, options);
        this.buildPipe(metadata);
        return this.createRawHandler(metadata);
    }
    createCustomHandler(provider, propertyKey) {
        const metadata = new mvc_1.HandlerMetadata({
            token: provider.provide,
            target: provider.useClass,
            type: mvc_1.HandlerType.CUSTOM,
            scope: provider.scope,
            propertyKey
        });
        this.buildPipe(metadata);
        return this.createRawHandler(metadata);
    }
    /**
     * Create handler metadata
     * @param obj
     * @param routeOptions
     */
    createHandlerMetadata(obj, routeOptions = {}) {
        return createHandlerMetadata_1.createHandlerMetadata(this.injector, obj, routeOptions);
    }
    /**
     * Send the response to the consumer.
     * @param data
     * @param ctx
     * @protected
     */
    async flush(data, ctx) {
        const { response, endpoint } = ctx;
        if (endpoint) {
            if (endpoint.view) {
                data = await this.render(data, ctx);
            }
            else if (shouldBeSerialized(data)) {
                data = this.injector.get(mvc_1.ConverterService).serialize(data, {
                    ...endpoint.getResponseOptions(),
                    endpoint: true
                });
            }
        }
        if (!response.isDone()) {
            const responseFilter = this.injector.get(PlatformResponseFilter_1.PlatformResponseFilter);
            response.body(responseFilter.transform(data, ctx));
        }
    }
    /**
     * Allow handler hack for AsyncHookContext plugin.
     * @param $ctx
     * @param cb
     * @protected
     */
    run($ctx, cb) {
        return cb();
    }
    /**
     * Get argument from parameter medata or handler context.
     * @param type
     * @param h
     */
    getArg(type, h) {
        const { $ctx } = h;
        switch (type) {
            case mvc_1.ParamTypes.NODE_RESPONSE:
                return $ctx.getRes();
            case mvc_1.ParamTypes.NODE_REQUEST:
                return $ctx.getReq();
            case mvc_1.ParamTypes.FILES:
                return $ctx.getRequest().files;
            case mvc_1.ParamTypes.RESPONSE:
                return $ctx.getResponse();
            case mvc_1.ParamTypes.REQUEST:
                return $ctx.getRequest();
            case mvc_1.ParamTypes.PLATFORM_RESPONSE:
                return $ctx.response;
            case mvc_1.ParamTypes.PLATFORM_REQUEST:
                return $ctx.request;
            case mvc_1.ParamTypes.NEXT_FN:
                return h.next;
            case mvc_1.ParamTypes.ERR:
                return h.err;
            case mvc_1.ParamTypes.$CTX: // tsed ctx
                return $ctx;
            case mvc_1.ParamTypes.ENDPOINT_INFO:
                return $ctx.endpoint;
            case mvc_1.ParamTypes.RESPONSE_DATA:
                return $ctx.data;
            case mvc_1.ParamTypes.BODY:
                return $ctx.request.body;
            case mvc_1.ParamTypes.RAW_BODY:
                return $ctx.request.rawBody;
            case mvc_1.ParamTypes.QUERY:
                return $ctx.request.query;
            case mvc_1.ParamTypes.PATH:
                return $ctx.request.params;
            case mvc_1.ParamTypes.HEADER:
                return $ctx.request.headers;
            case mvc_1.ParamTypes.COOKIES:
                return $ctx.request.cookies;
            case mvc_1.ParamTypes.SESSION:
                return $ctx.request.session;
            case mvc_1.ParamTypes.LOCALS:
                return $ctx.response.locals;
            default:
                return $ctx.getRequest();
        }
    }
    async onCtxRequest(requestOptions) {
        const { metadata, $ctx } = requestOptions;
        await metadata.handler($ctx);
        return this.next(requestOptions);
    }
    /**
     * Call handler when a request his handle
     * @param requestOptions
     */
    async onRequest(requestOptions) {
        // istanbul ignore next
        if (!requestOptions.$ctx) {
            logger_1.$log.error(`Endpoint ${requestOptions.metadata.toString()} is called but the response is already send to your consumer. Check your code and his middlewares please!`);
            return;
        }
        const h = new HandlerContext_1.HandlerContext({
            ...requestOptions,
            args: []
        });
        const { $ctx } = h;
        return this.run($ctx, async () => {
            try {
                h.args = await this.getArgs(h);
                await h.callHandler();
                if (h.status === HandlerContext_1.HandlerContextStatus.RESOLVED) {
                    // Can be canceled by the handler itself
                    return await this.onSuccess($ctx.data, requestOptions);
                }
            }
            catch (er) {
                return this.onError(er, requestOptions);
            }
        });
    }
    async onError(er, requestOptions) {
        const { next, $ctx } = requestOptions;
        $ctx.data = er;
        if (!next) {
            throw er;
        }
        return !$ctx.response.isHeadersSent() && next && next(er);
    }
    /**
     * Manage success scenario
     * @param data
     * @param requestOptions
     * @protected
     */
    async onSuccess(data, requestOptions) {
        const { metadata, $ctx, next } = requestOptions;
        if ($ctx.request.isAborted() || $ctx.response.isDone()) {
            return;
        }
        // set headers each times that an endpoint is called
        if (metadata.type === mvc_1.HandlerType.ENDPOINT) {
            this.setHeaders($ctx);
        }
        // call returned middleware
        if (core_1.isFunction(data) && !core_1.isStream(data)) {
            return this.callReturnedMiddleware(data, $ctx, next);
        }
        if (metadata.isFinal()) {
            return this.flush(data, $ctx);
        }
        return this.next(requestOptions);
    }
    /**
     * Call the returned middleware by the handler.
     * @param middleware
     * @param ctx
     * @param next
     * @protected
     */
    callReturnedMiddleware(middleware, ctx, next) {
        return middleware(ctx.getRequest(), ctx.getResponse(), next);
    }
    /**
     * Render the view if the endpoint has a configured view.
     * @param data
     * @param ctx
     * @protected
     */
    async render(data, ctx) {
        return renderView_1.renderView(data, ctx);
    }
    /**
     * create Raw handler
     * @param metadata
     */
    createRawHandler(metadata) {
        switch (metadata.type) {
            case mvc_1.HandlerType.CUSTOM:
                return (ctx, next) => this.onRequest({ metadata, next, $ctx: ctx });
            case mvc_1.HandlerType.RAW_ERR_FN:
            case mvc_1.HandlerType.RAW_FN:
                return metadata.handler;
            default:
            case mvc_1.HandlerType.ENDPOINT:
            case mvc_1.HandlerType.MIDDLEWARE:
                return (request, response, next) => this.onRequest({ metadata, next, $ctx: request.$ctx });
        }
    }
    buildPipe(metadata) {
        if (metadata.injectable) {
            metadata.parameters.forEach((param) => {
                param.cachePipes(this.injector);
            });
        }
    }
    /**
     * Set response headers
     * @param ctx
     * @protected
     */
    setHeaders(ctx) {
        return setResponseHeaders_1.setResponseHeaders(ctx);
    }
    next(requestOptions) {
        const { $ctx, next } = requestOptions;
        return !$ctx.response.isDone() && next && next();
    }
    /**
     * Return arguments to call handler
     * @param h
     */
    async getArgs(h) {
        const { metadata: { parameters } } = h;
        return Promise.all(parameters.map((param) => this.mapArg(param, h)));
    }
    /**
     * Map argument by calling pipe.
     * @param metadata
     * @param h
     */
    async mapArg(metadata, h) {
        const value = this.getArg(metadata.paramType, h);
        return metadata.getPipes().reduce(async (value, pipe) => {
            value = await value;
            try {
                return await pipe.transform(value, metadata);
            }
            catch (er) {
                throw ParamValidationError_1.ParamValidationError.from(metadata, er);
            }
        }, value);
    }
};
PlatformHandler = tslib_1.__decorate([
    di_1.Injectable({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], PlatformHandler);
exports.PlatformHandler = PlatformHandler;
//# sourceMappingURL=PlatformHandler.js.map