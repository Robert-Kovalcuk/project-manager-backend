"use strict";
var _rootModule, _injector, _providers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformBuilder = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const perf_1 = require("@tsed/perf");
const middlewares_1 = require("../middlewares");
const PlatformLogMiddleware_1 = require("../middlewares/PlatformLogMiddleware");
const PlatformModule_1 = require("../PlatformModule");
const Platform_1 = require("../services/Platform");
const PlatformApplication_1 = require("../services/PlatformApplication");
const PlatformHandler_1 = require("../services/PlatformHandler");
const PlatformRequest_1 = require("../services/PlatformRequest");
const PlatformResponse_1 = require("../services/PlatformResponse");
const PlatformRouter_1 = require("../services/PlatformRouter");
const PlatformViews_1 = require("../services/PlatformViews");
const utils_1 = require("../utils");
const SKIP_HOOKS = ["$beforeInit", "$afterInit", "$onInit", "$onMountingMiddlewares"];
const { bind, start, end, log } = perf_1.PerfLogger.get("bootstrap");
/**
 * @platform
 */
class PlatformBuilder {
    constructor({ name, providers }) {
        this.name = "";
        this.startedAt = new Date();
        _rootModule.set(this, void 0);
        _injector.set(this, void 0);
        _providers.set(this, void 0);
        this.name = name;
        tslib_1.__classPrivateFieldSet(this, _providers, core_1.toMap(providers, "provide"));
        this.locals = new di_1.Container();
        this.useProvider(PlatformHandler_1.PlatformHandler, tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformHandler_1.PlatformHandler))
            .useProvider(PlatformResponse_1.PlatformResponse, tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformResponse_1.PlatformResponse))
            .useProvider(PlatformRequest_1.PlatformRequest, tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformRequest_1.PlatformRequest))
            .useProvider(PlatformRouter_1.PlatformRouter, tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformRouter_1.PlatformRouter))
            .useProvider(PlatformApplication_1.PlatformApplication, tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformApplication_1.PlatformApplication))
            .useProvider(Platform_1.Platform, tslib_1.__classPrivateFieldGet(this, _providers).get(Platform_1.Platform));
    }
    get injector() {
        return tslib_1.__classPrivateFieldGet(this, _injector);
    }
    get rootModule() {
        return tslib_1.__classPrivateFieldGet(this, _rootModule);
    }
    get app() {
        return this.injector.get(PlatformApplication_1.PlatformApplication);
    }
    get platform() {
        return this.injector.get(Platform_1.Platform);
    }
    /**
     * Return the settings configured by the decorator @@Configuration@@.
     *
     * ```typescript
     * @Configuration({
     *    rootDir: Path.resolve(__dirname),
     *    port: 8000,
     *    httpsPort: 8080,
     *    mount: {
     *      "/rest": "${rootDir}/controllers/**\/*.js"
     *    }
     * })
     * export class Server {
     *     $onInit(){
     *         console.log(this.settings); // {rootDir, port, httpsPort,...}
     *     }
     * }
     * ```
     *
     * @returns {PlatformConfiguration}
     */
    get settings() {
        return this.injector.settings;
    }
    get logger() {
        return this.injector.logger;
    }
    get disableBootstrapLog() {
        return this.settings.logger.disableBootstrapLog;
    }
    static build(platformBuildClass) {
        return new platformBuildClass({
            name: core_1.nameOf(platformBuildClass).replace("Platform", "").toLowerCase(),
            providers: platformBuildClass.providers
        });
    }
    log(...data) {
        return this.disableBootstrapLog && this.logger.info(...data);
    }
    /**
     * Add classes to the components list
     * @param classes
     */
    addComponents(classes) {
        this.settings.componentsScan = this.settings.componentsScan.concat(classes);
        return this;
    }
    /**
     * Add classes decorated by @@Controller@@ to components container.
     *
     * ### Example
     *
     * ```typescript
     * @Controller('/ctrl')
     * class MyController{
     * }
     *
     * platform.addControllers('/rest', [MyController])
     * ```
     *
     * ::: tip
     * If the MyController class isn't decorated, the class will be ignored.
     * :::
     *
     * @param {string} endpoint
     * @param {any[]} controllers
     */
    addControllers(endpoint, controllers) {
        this.settings.mount[endpoint] = (this.settings.mount[endpoint] || []).concat(controllers);
    }
    async runLifecycle() {
        di_1.setLoggerLevel(this.injector);
        await this.importProviders();
        await this.loadInjector();
        this.useContext();
        this.useRouter();
        await this.loadRoutes();
        await this.logRoutes();
    }
    async loadInjector() {
        const { injector } = this;
        await this.callHook("$beforeInit");
        this.log("Build providers");
        const container = di_1.createContainer(core_1.constructorOf(this.rootModule));
        await injector.load(container, PlatformModule_1.PlatformModule);
        this.log("Settings and injector loaded");
        await this.callHook("$afterInit");
    }
    async listen() {
        await this.callHook("$beforeListen");
        await this.listenServers();
        await this.callHook("$afterListen");
        await this.ready();
        end();
    }
    async stop() {
        await this.callHook("$onDestroy");
        return this.injector.destroy();
    }
    async ready() {
        const { startedAt } = this;
        await this.callHook("$onReady");
        await this.injector.emit("$onServerReady");
        this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
    }
    async callHook(hook, ...args) {
        const { injector, rootModule } = this;
        log(hook);
        if (!injector.settings.logger.disableBootstrapLog) {
            injector.logger.info(`\x1B[1mCall hook ${hook}\x1B[22m`);
        }
        // call hook for the Server
        if (hook in rootModule) {
            await rootModule[hook](...args);
        }
        // Load middlewares for the given hook
        this.loadMiddlewaresFor(hook);
        // call hooks added by providers
        if (!SKIP_HOOKS.includes(hook)) {
            await injector.emit(hook);
        }
    }
    async loadStatics() {
        const { settings } = this;
        if (settings.statics) {
            Object.entries(settings.statics).forEach(([path, items]) => {
                [].concat(items).forEach((options) => {
                    const opts = typeof options === "string"
                        ? {
                            root: options
                        }
                        : options;
                    this.platform.app.statics(path, opts);
                });
            });
        }
    }
    useProvider(token, settings) {
        this.locals.addProvider(token, settings);
        return this;
    }
    async importProviders() {
        this.injector.logger.debug("Scan components");
        const providers = await di_1.importProviders(this.injector.settings, ["imports", "mount", "componentsScan"]);
        const routes = providers.filter((provider) => !!provider.route).map(({ route, token }) => ({ route, token }));
        this.settings.set("routes", routes);
    }
    createRequest(req) {
        const Klass = tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformRequest_1.PlatformRequest).useClass;
        return new Klass(req);
    }
    createResponse(res) {
        const Klass = tslib_1.__classPrivateFieldGet(this, _providers).get(PlatformResponse_1.PlatformResponse).useClass;
        const response = new Klass(res);
        response.platformViews = this.injector.get(PlatformViews_1.PlatformViews);
        return response;
    }
    /**
     * Load middlewares from configuration for the given hook
     * @param hook
     * @protected
     */
    loadMiddlewaresFor(hook) {
        const { settings } = this;
        const { env, middlewares = [] } = settings;
        const defaultHook = "$beforeRoutesInit";
        middlewares
            .map((middleware) => {
            return core_1.isFunction(middleware)
                ? {
                    env,
                    hook: defaultHook,
                    use: middleware
                }
                : {
                    env,
                    hook: defaultHook,
                    ...middleware
                };
        })
            .filter((options) => {
            return options.use && options.env === env && options.hook === hook;
        })
            .forEach(({ use }) => {
            this.app.use(use);
        });
    }
    useRouter() {
        return this;
    }
    useContext() {
        return this;
    }
    async bootstrap(module, settings = {}) {
        var _a;
        // istanbul ignore next
        if ((_a = settings.logger) === null || _a === void 0 ? void 0 : _a.perf) {
            start();
            bind(this);
            settings.logger = {
                ...settings.logger,
                level: "off"
            };
        }
        this.createInjector(module, {
            ...settings,
            PLATFORM_NAME: this.name
        });
        this.createRootModule(module);
        await this.runLifecycle();
        return this;
    }
    async listenServers() {
        await Promise.all([utils_1.listenHttpServer(this.injector), utils_1.listenHttpsServer(this.injector)]);
    }
    async logRoutes() {
        const { logger, platform } = this;
        if (!this.settings.logger.disableRoutesSummary && !this.disableBootstrapLog) {
            logger.info("Routes mounted :");
            logger.info(utils_1.printRoutes(await this.injector.alterAsync("$logRoutes", platform.getRoutes())));
        }
    }
    async loadRoutes() {
        var _a;
        // istanbul ignore next
        if (this.settings.logger.level !== "off") {
            this.app.use(PlatformLogMiddleware_1.PlatformLogMiddleware);
        }
        if ((_a = this.settings.acceptMimes) === null || _a === void 0 ? void 0 : _a.length) {
            this.app.use(middlewares_1.GlobalAcceptMimesMiddleware);
        }
        this.log("Load routes");
        await this.callHook("$beforeRoutesInit");
        await this.callHook("$$loadRoutes");
        await this.callHook("$onRoutesInit");
        await this.loadStatics();
        await this.callHook("$afterRoutesInit");
    }
    createInjector(module, settings) {
        const configuration = di_1.getConfiguration(module, settings);
        tslib_1.__classPrivateFieldSet(this, _injector, utils_1.createInjector(configuration));
        // configure locals providers
        this.locals.forEach((provider) => {
            this.injector.addProvider(provider.token, provider);
        });
        utils_1.createPlatformApplication(this.injector);
        utils_1.createHttpsServer(this.injector);
        utils_1.createHttpServer(this.injector);
    }
    createRootModule(module) {
        tslib_1.__classPrivateFieldSet(this, _rootModule, this.injector.invoke(module));
        this.injector.delete(core_1.constructorOf(tslib_1.__classPrivateFieldGet(this, _rootModule)));
        this.injector.delete(core_1.classOf(tslib_1.__classPrivateFieldGet(this, _rootModule)));
    }
}
exports.PlatformBuilder = PlatformBuilder;
_rootModule = new WeakMap(), _injector = new WeakMap(), _providers = new WeakMap();
//# sourceMappingURL=PlatformBuilder.js.map