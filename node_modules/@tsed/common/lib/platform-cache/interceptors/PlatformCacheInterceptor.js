"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformCacheInterceptor = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const http_1 = require("http");
const PlatformContext_1 = require("../../platform/domain/PlatformContext");
const PlatformCache_1 = require("../services/PlatformCache");
const cleanHeaders = (headers) => {
    return Object.entries(headers)
        .filter(([key]) => !["content-length", "x-request-id", "cache-control"].includes(key))
        .reduce((headers, [key, value]) => {
        return {
            ...headers,
            [key]: value
        };
    }, {});
};
/**
 * @platform
 */
let PlatformCacheInterceptor = class PlatformCacheInterceptor {
    async intercept(context, next) {
        if (this.cache.disabled()) {
            return next();
        }
        if (!this.isEndpoint(context)) {
            return this.cacheMethod(context, next);
        }
        return this.cacheResponse(context, next);
    }
    getArgs(context) {
        return context.args.reduce((args, arg) => {
            if (arg instanceof PlatformContext_1.PlatformContext || arg instanceof http_1.IncomingMessage || arg instanceof http_1.ServerResponse) {
                return args;
            }
            if (core_1.isClass(arg)) {
                return args.concat(json_mapper_1.serialize(arg));
            }
            return args.concat(arg);
        }, []);
    }
    getOptions(context) {
        const { ttl, type, collectionType, key: k = this.cache.defaultKeyResolver() } = context.options || {};
        const args = this.getArgs(context);
        const keyArgs = core_1.isString(k) ? k : k(args);
        return { ttl, type, args, collectionType, keyArgs };
    }
    isEndpoint({ target, propertyKey }) {
        return core_1.Store.fromMethod(target, propertyKey).has(schema_1.JsonEntityStore);
    }
    async cacheMethod(context, next) {
        const { ttl, type, collectionType, keyArgs, args } = this.getOptions(context);
        const key = [core_1.nameOf(context.target), context.propertyKey, keyArgs].join(":");
        const cachedObject = await this.cache.get(key);
        if (cachedObject) {
            const { data } = cachedObject;
            return json_mapper_1.deserialize(JSON.parse(data), { collectionType, type });
        }
        const result = await next();
        const calculatedTtl = this.cache.ttl(result, ttl);
        await this.cache.set(key, {
            ttl: calculatedTtl,
            args,
            data: JSON.stringify(json_mapper_1.serialize(result, { type, collectionType }))
        }, {
            ttl: calculatedTtl
        });
        return result;
    }
    async cacheResponse(context, next) {
        const $ctx = context.args[context.args.length - 1];
        const { request, response } = $ctx;
        if (request.method !== "GET") {
            return next();
        }
        const { ttl, args, keyArgs } = this.getOptions(context);
        const key = [request.method, request.url, keyArgs].join(":");
        const cachedObject = await this.cache.get(key);
        if (cachedObject && !(response.get("cache-control") === "no-cache")) {
            return this.sendResponse(cachedObject, $ctx);
        }
        const result = await next();
        const calculatedTtl = this.cache.ttl(result, ttl);
        const expires = calculatedTtl + Date.now() / 1000;
        $ctx.response.setHeaders({
            "cache-control": `max-age=${calculatedTtl}`
        });
        // cache final response with his headers and body
        response.onEnd(async () => {
            const data = JSON.stringify(response.getBody());
            const headers = cleanHeaders(response.getHeaders());
            await this.cache.set(key, {
                ttl: calculatedTtl,
                args,
                data,
                expires,
                headers
            }, {
                ttl: calculatedTtl
            });
        });
        return result;
    }
    sendResponse(cachedObject, $ctx) {
        const { headers, ttl } = cachedObject;
        const { request, response } = $ctx;
        const requestEtag = request.get("if-none-match");
        if (requestEtag && headers.etag === requestEtag) {
            response.status(304).setHeaders(headers).body(undefined);
            return undefined;
        }
        const data = JSON.parse(cachedObject.data);
        $ctx.response
            .setHeaders({
            ...headers,
            "x-cached": "true",
            "cache-control": `max-age=${ttl}`
        })
            .body(data);
        return data;
    }
};
tslib_1.__decorate([
    di_1.Inject(),
    tslib_1.__metadata("design:type", PlatformCache_1.PlatformCache)
], PlatformCacheInterceptor.prototype, "cache", void 0);
PlatformCacheInterceptor = tslib_1.__decorate([
    di_1.Interceptor()
], PlatformCacheInterceptor);
exports.PlatformCacheInterceptor = PlatformCacheInterceptor;
//# sourceMappingURL=PlatformCacheInterceptor.js.map