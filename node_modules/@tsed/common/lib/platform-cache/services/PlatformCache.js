"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformCache = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const cache_manager_1 = tslib_1.__importDefault(require("cache-manager"));
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
const defaultKeyResolver = (args) => {
    return args.map((arg) => (core_1.isClass(arg) ? JSON.stringify(json_mapper_1.serialize(arg)) : arg)).join(":");
};
/**
 * @platform
 */
let PlatformCache = class PlatformCache {
    disabled() {
        return !this.settings.get("cache");
    }
    $onInit() {
        const settings = this.settings.get("cache");
        if (settings) {
            const { caches, store = "memory", ttl, ...props } = settings;
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            this.cache = (caches === null || caches === void 0 ? void 0 : caches.length)
                ? cache_manager_1.default.multiCaching(caches, { ...props })
                : cache_manager_1.default.caching({
                    ...props,
                    ttl,
                    store
                });
        }
    }
    defaultKeyResolver() {
        return this.settings.get("cache.keyResolver", defaultKeyResolver);
    }
    defaultTtl() {
        return this.settings.get("cache.ttl");
    }
    ttl(result, currentTtl) {
        const ttl = currentTtl === undefined ? this.defaultTtl() : currentTtl;
        return core_1.isFunction(ttl) ? ttl(result) : ttl;
    }
    wrap(key, fetch, options) {
        var _a;
        if (!this.cache) {
            return fetch();
        }
        return (_a = this.cache) === null || _a === void 0 ? void 0 : _a.wrap(key, fetch, options);
    }
    async get(key, options = {}) {
        var _a;
        return json_mapper_1.deserialize((_a = this.cache) === null || _a === void 0 ? void 0 : _a.get(key), options);
    }
    async set(key, value, options) {
        var _a;
        return (_a = this.cache) === null || _a === void 0 ? void 0 : _a.set(key, value, options);
    }
    async del(key) {
        var _a;
        await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.del(key));
    }
    async reset() {
        var _a;
        // @ts-ignore
        await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.reset());
    }
    async keys() {
        var _a;
        if ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.keys) {
            return this.cache.keys();
        }
        // istanbul ignore next
        return [];
    }
    async getMatchingKeys(patterns) {
        const keys = await this.keys();
        return micromatch_1.default(keys, patterns);
    }
    async deleteMatchingKeys(patterns) {
        const keys = await this.getMatchingKeys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
};
tslib_1.__decorate([
    di_1.Configuration(),
    tslib_1.__metadata("design:type", Object)
], PlatformCache.prototype, "settings", void 0);
PlatformCache = tslib_1.__decorate([
    di_1.Injectable()
], PlatformCache);
exports.PlatformCache = PlatformCache;
//# sourceMappingURL=PlatformCache.js.map