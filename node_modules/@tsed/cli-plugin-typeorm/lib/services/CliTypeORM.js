"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliTypeORM = void 0;
const tslib_1 = require("tslib");
const cli_core_1 = require("@tsed/cli-core");
const di_1 = require("@tsed/di");
const change_case_1 = require("change-case");
const path_1 = require("path");
const templateDir_1 = require("../utils/templateDir");
let CliTypeORM = class CliTypeORM {
    run(command, args, options = {}) {
        return this.cliExeca.run("npx", ["typeorm", command, ...args], {
            ...options,
            cwd: this.projectPackageJson.dir
        });
    }
    async generateConnection(name, options = {}) {
        return this.srcRenderer.render("connection.hbs", {
            ...options,
            symbolName: change_case_1.constantCase(options.symbolName),
            connectionName: name
        }, {
            templateDir: templateDir_1.TEMPLATE_DIR,
            output: `${options.symbolPath}.ts`,
            rootDir: path_1.join(this.srcRenderer.rootDir, "services", "connections")
        });
    }
    async writeConfig(name, database) {
        var _a, _b, _c;
        const { InitCommand } = await this.projectPackageJson.importModule("typeorm/commands/InitCommand.js");
        const content = {
            name,
            ...JSON.parse(await InitCommand.getOrmConfigTemplate(database))
        };
        function replace(path) {
            return path && path.replace("src/", "${rootDir}/").replace(/\.ts/, ".{js,ts}");
        }
        content.entities = (_a = content.entities) === null || _a === void 0 ? void 0 : _a.map(replace);
        content.migrations = (_b = content.migrations) === null || _b === void 0 ? void 0 : _b.map(replace);
        content.subscribers = (_c = content.subscribers) === null || _c === void 0 ? void 0 : _c.map(replace);
        if (content.cli) {
            content.cli.entitiesDir = replace(content.cli.entitiesDir);
            content.cli.migrationsDir = replace(content.cli.migrationsDir);
            content.cli.subscribersDir = replace(content.cli.subscribersDir);
        }
        await this.srcRenderer.write(JSON.stringify(content, null, 2), { output: `config/typeorm/${name}.config.json` });
        return this.regenerateIndexConfig();
    }
    async regenerateIndexConfig() {
        const list = await this.srcRenderer.scan(["config/typeorm/*.config.json"]);
        const configs = list.map((file) => {
            const name = path_1.basename(file).replace(/\.config\.json/gi, "");
            return {
                name,
                symbolName: change_case_1.camelCase(name)
            };
        });
        return this.srcRenderer.render("index.hbs", {
            configs
        }, {
            templateDir: templateDir_1.TEMPLATE_DIR,
            output: "index.ts",
            rootDir: path_1.join(this.srcRenderer.rootDir, "config", "typeorm")
        });
    }
};
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", cli_core_1.CliExeca)
], CliTypeORM.prototype, "cliExeca", void 0);
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", cli_core_1.ProjectPackageJson)
], CliTypeORM.prototype, "projectPackageJson", void 0);
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", cli_core_1.SrcRendererService)
], CliTypeORM.prototype, "srcRenderer", void 0);
CliTypeORM = tslib_1.__decorate([
    di_1.Injectable()
], CliTypeORM);
exports.CliTypeORM = CliTypeORM;
//# sourceMappingURL=CliTypeORM.js.map