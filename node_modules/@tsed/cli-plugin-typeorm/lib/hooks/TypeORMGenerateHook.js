"use strict";
var TypeORMGenerateHook_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeORMGenerateHook = void 0;
const tslib_1 = require("tslib");
const cli_1 = require("@tsed/cli");
const cli_core_1 = require("@tsed/cli-core");
const di_1 = require("@tsed/di");
const change_case_1 = require("change-case");
const CliTypeORM_1 = require("../services/CliTypeORM");
let TypeORMGenerateHook = TypeORMGenerateHook_1 = class TypeORMGenerateHook {
    constructor(providersInfoService) {
        this.providersInfoService = providersInfoService;
        providersInfoService.add({
            name: "TypeORM Connection",
            value: "typeorm:connection",
            model: "{{symbolName}}.connection"
        }, TypeORMGenerateHook_1);
    }
    async onGeneratePrompt() {
        const list = cli_1.FEATURES_TYPEORM_CONNECTION_TYPES.map((item) => {
            return {
                name: item.name,
                value: item.value.type
            };
        });
        return [
            {
                type: "autocomplete",
                name: "typeormConnection",
                message: "Which passport package ?",
                when(state) {
                    return ["typeorm:connection"].includes(state.type);
                },
                source: async (state, keyword) => {
                    if (keyword) {
                        return list.filter((item) => item.name.toLowerCase().includes(keyword.toLowerCase()));
                    }
                    return list;
                }
            }
        ];
    }
    onGenerateExec(ctx) {
        var _a;
        if (this.providersInfoService.isMyProvider(ctx.type, TypeORMGenerateHook_1)) {
            ctx = this.mapOptions(ctx);
            const { typeormConnection, symbolPath } = ctx;
            const connection = cli_1.FEATURES_TYPEORM_CONNECTION_TYPES.find((item) => item.value.type === typeormConnection);
            if ((_a = connection === null || connection === void 0 ? void 0 : connection.value) === null || _a === void 0 ? void 0 : _a.dependencies) {
                this.projectPackageJson.addDependencies((connection === null || connection === void 0 ? void 0 : connection.value.dependencies) || {});
            }
            const database = ctx.typeormConnection.split(":")[1];
            return [
                {
                    title: `Generate TypeORM connection file to '${symbolPath}.ts'`,
                    task: () => this.cliTypeORM.generateConnection(ctx.name, ctx)
                },
                {
                    title: `Generate TypeORM configuration file to '${ctx.connectionName}.config.json'`,
                    task: () => this.cliTypeORM.writeConfig(ctx.connectionName, database)
                },
                {
                    title: "Generate docker-compose configuration",
                    task: async () => this.cliDockerComposeYaml.addDatabaseService(ctx.name, database)
                }
            ];
        }
        return [];
    }
    mapOptions(options) {
        return {
            ...options,
            connectionName: change_case_1.paramCase(options.name).replace("-connection", "")
        };
    }
};
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", cli_core_1.ProjectPackageJson)
], TypeORMGenerateHook.prototype, "projectPackageJson", void 0);
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", cli_core_1.SrcRendererService)
], TypeORMGenerateHook.prototype, "srcRenderService", void 0);
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", CliTypeORM_1.CliTypeORM)
], TypeORMGenerateHook.prototype, "cliTypeORM", void 0);
tslib_1.__decorate([
    cli_core_1.Inject(),
    tslib_1.__metadata("design:type", cli_core_1.CliDockerComposeYaml)
], TypeORMGenerateHook.prototype, "cliDockerComposeYaml", void 0);
tslib_1.__decorate([
    cli_core_1.OnPrompt("generate"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", Promise)
], TypeORMGenerateHook.prototype, "onGeneratePrompt", null);
tslib_1.__decorate([
    cli_core_1.OnExec("generate"),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Array)
], TypeORMGenerateHook.prototype, "onGenerateExec", null);
TypeORMGenerateHook = TypeORMGenerateHook_1 = tslib_1.__decorate([
    di_1.Injectable(),
    tslib_1.__metadata("design:paramtypes", [cli_1.ProvidersInfoService])
], TypeORMGenerateHook);
exports.TypeORMGenerateHook = TypeORMGenerateHook;
//# sourceMappingURL=TypeORMGenerateHook.js.map