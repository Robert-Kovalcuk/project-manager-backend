"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AjvService = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const schema_1 = require("@tsed/schema");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const AjvValidationError_1 = require("../errors/AjvValidationError");
const defaultErrorFormatter_1 = require("../utils/defaultErrorFormatter");
require("./Ajv");
const getPath_1 = require("../utils/getPath");
let AjvService = class AjvService {
    async validate(value, options) {
        let { schema, type, collectionType, ...additionalOptions } = this.mapOptions(options);
        schema = schema || schema_1.getJsonSchema(type, { ...additionalOptions, customKeys: true });
        if (schema) {
            const localValue = core_1.deepClone(value);
            const valid = await this.ajv.validate(schema, localValue);
            if (!valid) {
                throw this.mapErrors(this.ajv.errors || [], {
                    type,
                    collectionType,
                    async: true,
                    value: localValue
                });
            }
        }
        return value;
    }
    mapOptions(options) {
        if (options instanceof schema_1.JsonSchema) {
            return {
                schema: options.toJSON({ customKeys: true })
            };
        }
        return options;
    }
    mapErrors(errors, options) {
        const { type, collectionType, value } = options;
        const message = errors
            .map((error) => {
            if (collectionType) {
                error.collectionName = core_1.nameOf(collectionType);
            }
            const dataPath = getPath_1.getPath(error);
            if (!error.data) {
                if (dataPath) {
                    error.data = core_1.getValue(value, dataPath);
                }
                else if (error.schemaPath !== "#/required") {
                    error.data = value;
                }
            }
            if (dataPath && dataPath.match(/pwd|password|mdp|secret/)) {
                error.data = "[REDACTED]";
            }
            if (type) {
                error.modelName = core_1.nameOf(type);
                error.message = this.mapClassError(error, type);
            }
            return this.errorFormatter.call(this, error, {});
        })
            .join("\n");
        return new AjvValidationError_1.AjvValidationError(message, errors);
    }
    mapClassError(error, targetType) {
        const propertyKey = core_1.getValue(error, "params.missingProperty");
        if (propertyKey) {
            const store = schema_1.JsonEntityStore.from(core_1.prototypeOf(targetType), propertyKey);
            if (store) {
                core_1.setValue(error, "params.missingProperty", store.name || propertyKey);
                return error.message.replace(`'${propertyKey}'`, `'${store.name || propertyKey}'`);
            }
        }
        return error.message;
    }
};
tslib_1.__decorate([
    di_1.Constant("ajv.errorFormatter", defaultErrorFormatter_1.defaultErrorFormatter),
    tslib_1.__metadata("design:type", Function)
], AjvService.prototype, "errorFormatter", void 0);
tslib_1.__decorate([
    di_1.Inject(),
    tslib_1.__metadata("design:type", ajv_1.default)
], AjvService.prototype, "ajv", void 0);
AjvService = tslib_1.__decorate([
    di_1.Injectable()
], AjvService);
exports.AjvService = AjvService;
//# sourceMappingURL=AjvService.js.map