{"version":3,"file":"ProtocolsService.js","sourceRoot":"","sources":["../../src/services/ProtocolsService.ts"],"names":[],"mappings":"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","sourcesContent":["import {PlatformContext, PlatformHandler} from \"@tsed/common\";\nimport {ancestorsOf} from \"@tsed/core\";\nimport {Injectable, InjectorService, Provider} from \"@tsed/di\";\nimport {Unauthorized} from \"@tsed/exceptions\";\nimport Passport, {Strategy} from \"passport\";\nimport {PassportException} from \"../errors/PassportException\";\nimport {IProtocol, ProtocolOptions} from \"../interfaces\";\nimport {PROVIDER_TYPE_PROTOCOL} from \"../contants\";\nimport {promisify} from \"util\";\n\n/**\n * @ignore\n */\n@Injectable()\nexport class ProtocolsService {\n  readonly strategies: Map<string, Strategy> = new Map();\n\n  constructor(private injector: InjectorService) {}\n\n  public getProtocols(): Provider[] {\n    return Array.from(this.injector.getProviders(PROVIDER_TYPE_PROTOCOL));\n  }\n\n  public getProtocolsNames(): string[] {\n    return Array.from(this.strategies.keys());\n  }\n\n  /**\n   * Invoke provider and bind it to passport.\n   * @param provider\n   */\n  public invoke(provider: Provider): any {\n    const {name, useStrategy: strategy, settings} = this.getOptions(provider);\n    const protocol = this.injector.get<IProtocol & any>(provider.provide)!;\n    const instance = new strategy(settings, this.createHandler(provider));\n\n    this.strategies.set(name, instance);\n\n    Passport.use(name, instance);\n\n    if (protocol.$onInstall) {\n      protocol.$onInstall(instance);\n    }\n\n    protocol.$strategy = instance;\n\n    return protocol;\n  }\n\n  /**\n   * Call authenticate passport method.\n   * @param protocols\n   * @param options\n   * @param ctx\n   */\n  public async authenticate(protocols: string | string[], options: Record<string, any>, ctx: PlatformContext) {\n    return this.call(\"authenticate\", protocols, options, ctx);\n  }\n\n  /**\n   * Call authorize passport method.\n   * @param protocols\n   * @param options\n   * @param ctx\n   */\n  public async authorize(protocols: string | string[], options: Record<string, any>, ctx: PlatformContext) {\n    return this.call(\"authorize\", protocols, options, ctx);\n  }\n\n  /**\n   * Call passport authenticate or authorize depending on the chosen method.\n   * @param method\n   * @param protocols\n   * @param options\n   * @param ctx\n   * @private\n   */\n  private async call(\n    method: \"authenticate\" | \"authorize\",\n    protocols: string | string[],\n    options: Record<string, any>,\n    ctx: PlatformContext\n  ) {\n    const request = ctx.getRequest();\n    const response = ctx.getResponse();\n    protocols = ([] as string[]).concat(protocols);\n\n    if (protocols.length === 0) {\n      throw new Unauthorized(\"Not authorized\");\n    }\n\n    try {\n      options.failWithError = true;\n      // @ts-ignore\n      const fn = promisify(Passport[method](protocols.length === 1 ? protocols[0] : protocols, options));\n\n      await fn(request, response);\n    } catch (er) {\n      if (!ancestorsOf(er).includes(Error)) {\n        throw new PassportException(er);\n      }\n\n      throw er;\n    }\n  }\n\n  /**\n   * Create strategy options based on decorator metadata and global configuration\n   * @param provider\n   * @private\n   */\n  private getOptions(provider: Provider<any>): ProtocolOptions {\n    const {name} = provider.store.get(\"protocol\");\n    const {useStrategy = Strategy, settings = {}}: ProtocolOptions = this.injector.settings.get(`passport.protocols.${name}`) || {};\n\n    return {\n      name,\n      useStrategy,\n      settings: {\n        ...settings,\n        passReqToCallback: true\n      }\n    };\n  }\n\n  /**\n   * Create the verifier handler for passport\n   * @param provider\n   * @private\n   */\n  private createHandler(provider: Provider<any>) {\n    const platformHandler = this.injector.get<PlatformHandler>(PlatformHandler)!;\n    const middleware = platformHandler.createCustomHandler(provider, \"$onVerify\");\n\n    return async (req: any, ...args: any[]) => {\n      const done = args[args.length - 1];\n      req.$ctx.set(\"PROTOCOL_ARGS\", args.slice(0, -1));\n\n      try {\n        await middleware(req.$ctx);\n        done(null, ...[].concat(req.$ctx.data));\n      } catch (err) {\n        done(err, false, {message: err.message});\n      }\n    };\n  }\n}\n"]}