"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolsService = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const exceptions_1 = require("@tsed/exceptions");
const passport_1 = tslib_1.__importStar(require("passport"));
const PassportException_1 = require("../errors/PassportException");
const contants_1 = require("../contants");
const util_1 = require("util");
/**
 * @ignore
 */
let ProtocolsService = class ProtocolsService {
    constructor(injector) {
        this.injector = injector;
        this.strategies = new Map();
    }
    getProtocols() {
        return Array.from(this.injector.getProviders(contants_1.PROVIDER_TYPE_PROTOCOL));
    }
    getProtocolsNames() {
        return Array.from(this.strategies.keys());
    }
    /**
     * Invoke provider and bind it to passport.
     * @param provider
     */
    invoke(provider) {
        const { name, useStrategy: strategy, settings } = this.getOptions(provider);
        const protocol = this.injector.get(provider.provide);
        const instance = new strategy(settings, this.createHandler(provider));
        this.strategies.set(name, instance);
        passport_1.default.use(name, instance);
        if (protocol.$onInstall) {
            protocol.$onInstall(instance);
        }
        protocol.$strategy = instance;
        return protocol;
    }
    /**
     * Call authenticate passport method.
     * @param protocols
     * @param options
     * @param ctx
     */
    async authenticate(protocols, options, ctx) {
        return this.call("authenticate", protocols, options, ctx);
    }
    /**
     * Call authorize passport method.
     * @param protocols
     * @param options
     * @param ctx
     */
    async authorize(protocols, options, ctx) {
        return this.call("authorize", protocols, options, ctx);
    }
    /**
     * Call passport authenticate or authorize depending on the chosen method.
     * @param method
     * @param protocols
     * @param options
     * @param ctx
     * @private
     */
    async call(method, protocols, options, ctx) {
        const request = ctx.getRequest();
        const response = ctx.getResponse();
        protocols = [].concat(protocols);
        if (protocols.length === 0) {
            throw new exceptions_1.Unauthorized("Not authorized");
        }
        try {
            options.failWithError = true;
            // @ts-ignore
            const fn = util_1.promisify(passport_1.default[method](protocols.length === 1 ? protocols[0] : protocols, options));
            await fn(request, response);
        }
        catch (er) {
            if (!core_1.ancestorsOf(er).includes(Error)) {
                throw new PassportException_1.PassportException(er);
            }
            throw er;
        }
    }
    /**
     * Create strategy options based on decorator metadata and global configuration
     * @param provider
     * @private
     */
    getOptions(provider) {
        const { name } = provider.store.get("protocol");
        const { useStrategy = passport_1.Strategy, settings = {} } = this.injector.settings.get(`passport.protocols.${name}`) || {};
        return {
            name,
            useStrategy,
            settings: {
                ...settings,
                passReqToCallback: true
            }
        };
    }
    /**
     * Create the verifier handler for passport
     * @param provider
     * @private
     */
    createHandler(provider) {
        const platformHandler = this.injector.get(common_1.PlatformHandler);
        const middleware = platformHandler.createCustomHandler(provider, "$onVerify");
        return async (req, ...args) => {
            const done = args[args.length - 1];
            req.$ctx.set("PROTOCOL_ARGS", args.slice(0, -1));
            try {
                await middleware(req.$ctx);
                done(null, ...[].concat(req.$ctx.data));
            }
            catch (err) {
                done(err, false, { message: err.message });
            }
        };
    }
};
ProtocolsService = tslib_1.__decorate([
    di_1.Injectable(),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], ProtocolsService);
exports.ProtocolsService = ProtocolsService;
//# sourceMappingURL=ProtocolsService.js.map